set.seed(1)
y <- rnorm(100)
x <- rnorm(100)
y <- x - 2 * x^2 + rnorm(100)
fun.y <- function(x) return(x - 2 * x^2)
#b
data.xy <- data.frame(x, y)
ggplot(data = data.xy, aes(x = x, y = y)) +
geom_point() +
stat_function(fun = fun.y, linetype = 2)
#c
set.seed(2)
cv.error <- rep(0, 4)
for (i in 1:4){
glm.fit <- glm(y ~ poly(x,i), data = data.xy)
cv.error[i] <- cv.glm(data.xy, glm.fit)$delta[1]
}
cv.error
#d
set.seed(3)
cv.error2 <- rep(0, 4)
for (i in 1:4){
glm.fit <- glm(y ~ poly(x,i), data = data.xy)
cv.error2[i] <- cv.glm(data.xy, glm.fit)$delta[1]
}
cv.error2
#f
lm.fit <- list()
coefs <- list()
coefs <- rep(NA, 4)
for (i in 1:4){
lm.fit <- lm(y ~ poly(x,i), data = data.xy)
coefs[i] <- summary(lm.fit)[4]
}
coefs
b0=-1.827
b1=2.316
b2=-21.0585
library(scatterplot3d)
x <- x
y <- x^2
z <- data.xy$y
scatterplot3d(x,y,z)
z.fit <-b0+b1*x+b2*y
scatterplot3d(x,y,z.fit)
plot(y,z)
plot(x,z)
plot(y,z)
plot(x,z)
scatterplot3d(x,y,z.fit)
scatterplot3d(x,y,z)
scatterplot3d(x,y,z.fit)
x.1 <-seq(-2,2,0.01)
x.2 <-seq(-2,2,0.01)
z.fit <-b0+b1*x.1+b2*x.2
scatterplot3d(x.1,x.2,z.fit)
?scatterplot3d
b0
b1
b2
x <- seq(-1, 1, 0.1)
y <- -x + rnorm(20)
y <- -x + rnorm(21)
y
lm(y ~ x)
y <- -x + x^2 + rnorm(21)
lm(y ~ x)
lm(y ~ x + x^2)
lm(y ~ x + I(x^2))
rm(list = ls())
library(ISLR)
library(ggplot2)
library(boot)
#8
#a
set.seed(1)
y <- rnorm(100)
x <- rnorm(100)
y <- x - 2 * x^2 + rnorm(100)
fun.y <- function(x) return(x - 2 * x^2)
#b
data.xy <- data.frame(x, y)
ggplot(data = data.xy, aes(x = x, y = y)) +
geom_point() +
stat_function(fun = fun.y, linetype = 2)
#c
set.seed(2)
cv.error <- rep(0, 4)
for (i in 1:4){
glm.fit <- glm(y ~ poly(x,i), data = data.xy)
cv.error[i] <- cv.glm(data.xy, glm.fit)$delta[1]
}
cv.error
#d
set.seed(3)
cv.error2 <- rep(0, 4)
for (i in 1:4){
glm.fit <- glm(y ~ poly(x,i), data = data.xy)
cv.error2[i] <- cv.glm(data.xy, glm.fit)$delta[1]
}
cv.error2
#f
lm.fit <- list()
coefs <- list()
coefs <- rep(NA, 4)
for (i in 1:4){
lm.fit <- lm(y ~ poly(x,i), data = data.xy)
coefs[i] <- summary(lm.fit)[4]
}
coefs
#9
library(MASS)
attach(Boston)
#a
mean <- mean(medv)
#b
mean.std <- sd(medv) / sqrt(length(medv))
mean.std
#c
set.seed(1)
mean.fn <- function(data, index)
return(c(mean(data[index]),
var(data[index]) / length(data)))
library(boot)
mean.boot <- boot(medv, mean.fn, R = 1000)
mean.boot
#d
ci.t <- t.test(medv)$conf.int
attr(ci.t, "conf.level") <- NULL
ci.boot <- boot.ci(mean.boot)$normal[c(2,3)]
ci.t
ci.boot
#e
median.medv <- median(medv)
median.medv
#f
median.fn <- function(data, index)
return(median(data[index]))
median.boot <- boot(medv, median.fn, R = 1000)
median.boot
#g
q.10.medv <- quantile(medv, probs = 0.1)
q.10.medv
#h
q.10.fn <- function(data, index)
return(quantile(data[index], probs = 0.1))
q.10.boot <- boot(medv, q.10.fn, R = 1000)
q.10.boot
p <- seq(0, 1, 0.01)
k <- sqrt(p * (1 - p)) / (sqrt(506) * dnorm(qnorm(p)))
plot(p,k)
#3
pages <- read.table(file = "./pages.dat")
names(pages) <- c("date",
"pages",
"countliners",
"inchesliners",
"linersdisplay")
par(mar = c(2, 2, 2, 2))
pairs(pages)
correlation <- cor(pages)
regressor <- c(names(pages)[3],
names(pages)[4],
names(pages)[5],
paste(names(pages)[3],
names(pages)[4],
sep = " * "),
paste(names(pages)[3],
names(pages)[5],
sep = " * "),
paste(names(pages)[4],
names(pages)[5],
sep = " * "),
paste(names(pages)[3],
names(pages)[4],
names(pages)[5],
sep = " * "))
indices <- expand.grid(c(TRUE, FALSE),
c(TRUE, FALSE),
c(TRUE, FALSE),
c(TRUE, FALSE),
c(TRUE, FALSE),
c(TRUE, FALSE),
c(TRUE, FALSE)
)
cvError <- rep(NA, 127)
for (n in 1:127){
lmformula <- reformulate(regressor[as.logical(indices[n, ])],
response = "pages")
glm.fit <- glm(lmformula, data = pages)
cvError[n] <- cv.glm(data = pages,
glmfit = glm.fit,
K = 5)$delta[2]
names(cvError)[n] <- paste(regressor[as.logical(indices[n, ])],
collapse = " + ")
}
best <- names(which.min(cvError))
best.lm <- lm(as.formula(paste("pages", best, sep = " ~ ")),
data = pages)
res <- resid(best.lm)
yhat <- predict(best.lm)
plot(yhat, res)
#4
des <- read.table(file = "./des_site1and2sp_2.dat",
col.names = c("glu",
"nud",
"utmn",
"utme",
"sw",
"elevation",
"slope",
"geology",
"LTA",
"ELT",
"site",
"subplot"))
attach(des)
glu <- as.factor(glu)
geology <- as.factor(geology)
LTA <- as.factor(LTA)
ELT <- as.factor(ELT)
site <- as.factor(site)
costFunction <- function(y, yhat) return(mean(y != (yhat > 0.5)))
cvError.inter <- rep(NA, 15)
cvError.noint <- rep(NA, 15)
n <- 1
for (i in 5:9){
for (j in (i+1):10){
glmformula.inter <- as.formula(
paste("glu ~ (",
paste(names(des)[c(i, j)],
collapse = " + "),
")^2"
)
)
glmformula.noint <- as.formula(
paste("glu ~ ",
paste(names(des)[c(i, j)],
collapse = " + ")
)
)
logis.fit.inter <- glm(glmformula.inter,
family = "binomial",
data = des)
logis.fit.noint <- glm(glmformula.noint,
family = "binomial",
data = des)
cvError.inter[n] <- cv.glm(data = des,
glmfit = logis.fit.inter,
cost = costFunction,
K = 10)$delta[1]
cvError.noint[n] <- cv.glm(data = des,
glmfit = logis.fit.noint,
cost = costFunction,
K = 10)$delta[1]
names(cvError.inter)[n] <- paste(
as.character(glmformula.inter)[2],
as.character(glmformula.inter)[1],
as.character(glmformula.inter)[3],
collapse = " ")
names(cvError.noint)[n] <- paste(
as.character(glmformula.noint)[2],
as.character(glmformula.noint)[1],
as.character(glmformula.noint)[3],
collapse = " ")
n <- n + 1
}
}
best.inter <- min(cvError.inter)
best.noint <- min(cvError.noint)
names(best.inter) <- names(cvError.inter)[which.min(cvError.inter)]
names(best.noint) <- names(cvError.noint)[which.min(cvError.inter)]
x <- seq(-1, 1, 0.1)
x2 <- x^2
y=x-2x
y<-x-2*x
lm(y~x)
lm(y~x+x^2)
lm(y~x+I(x^2)
)
lm(y~poly(x,2))
lm(y~poly(x,2))
z<x^2
z<-x^2
lm(y~x+z
)
?lm
x <- seq(-1, 1, 0.5)
x2 <- x^2
y <- x - 2*x2
fit  <- lm(y~x)
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 50 numbers starting from 30 and ending at 160
xx <- seq(30,160, length=50)
plot(x,y,pch=19,ylim=c(0,150))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 50 numbers starting from 30 and ending at 160
xx <- seq(30,160, length=50)
plot(x,y,pch=19)
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 50 numbers starting from 30 and ending at 160
xx <- seq(-1,1, length=50)
plot(x,y,pch=19)
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
x <- seq(-1, 1, length = `0)
`
x <- seq(-1, 1, length = 10)
x2 <- x^2
y <- x - 2*x2
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 50 numbers starting from 30 and ending at 160
xx <- seq(-1,1, length=50)
plot(x,y,pch=19)
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
summary(fit2)
x <- seq(-1, 1, 0.01)
x2 <- x^2
y <- x - 2*x2
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 50 numbers starting from 30 and ending at 160
xx <- seq(-1,1, length=50)
plot(x,y,pch=19)
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
summary(fit2)
lm(y~poly(x,2))
lm(y~poly(x,2,raw = T))
?poly
ploy(x,10)
poly(x,2)
x<- c(-1,0,1)
poly(x,2)
str(poly(x))
x
y <- ploy(x)
y <- poly(x)
x <- seq(-1,1, length = 50)
y <- poly(x)
plot(x, y, pch = 20)
y
y <- poly(x, 2)
plot(x, y, pch = 20)
plot(x, y[,2], pch = 20)
lm(y <- x+I(x^2))
lm(y ~ x+I(x^2))
lm(y[,2] ~ x+I(x^2))
y
y[,2]
y <- poly(x, 2)
y[,2]
y
lm(y[,2] ~ x+I(x^2))
y
poly(1:10, 3)
?poly
install.packages("Rweibo")
install.packages("dplyr")
library(dplyr)
?dplyr
?poly
install.packages("RMySql")
install.packages("RMySQL")
install.packages("RMySQL")
ucscDb <- dbConnect(MySQL(), user = "genome", host = "genome-mysql.cse.ucsc.edu")
library(RMySQL)
library(DBI)
library(RMySQL)
ucscDb <- dbConnect(MySQL(), user = "genome", host = "genome-mysql.cse.ucsc.edu")
result <- dbQuery(uscsDb, "show databases;")
result <- dbGetQuery(uscsDb, "show databases;")
result <- dbGetQuery(ucscDb, "show databases;")
result
dbDisconnect()
dbDisconnect(ucscDb)
?"fetch"
getwd
getwd()
download.file(url = "http://bioconductor.org/biocLite.R", destfile = "./bioLite.R")
source("./bioLite.R")
biocLite("rhdf5")
library(rhdf5)
library(XML)
library(httr)
update.packages()
install.packages("foreign")
setwd("~/Documents/git/DataAnalysis3")
